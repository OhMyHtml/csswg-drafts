<pre class='metadata'>
Title: CSS Positioned Layout Module Level 3
Status: ED
Work Status: Exploring
Shortname: css-position
Level: 3
Group: csswg
ED: https://drafts.csswg.org/css-position/
TR: https://www.w3.org/TR/css-position-3/
Previous Version: https://www.w3.org/TR/2016/WD-css-position-3-20160517/
Previous Version: https://www.w3.org/TR/2015/WD-css3-positioning-20150203/
Previous Version: https://www.w3.org/TR/2012/WD-css3-positioning-20120207/
Editor: Elika J. Etemad / fantasai, Invited Expert, http://fantasai.inkedblade.net/contact, w3cid 35400
Editor: Tab Atkins Jr., Google, http://xanthir.com/contact/, w3cid 42199
Former Editor: Rossen Atanassov, Microsoft, ratan@microsoft.com, w3cid 49885
Former Editor: Arron Eicholz, Microsoft, arronei@microsoft.com, w3cid 37934
!Issues list: <a href="http://wiki.csswg.org/spec/css-position/">in Wiki</a>
Abstract: This module contains defines coordinate-based positioning and offsetting schemes of <a href="https://www.w3.org/TR/CSS/">CSS</a>: [=relative positioning=], [=sticky positioning=], [=absolute positioning=], and [=fixed positioning=].
Link Defaults: css-transforms-1 (property) transform
</pre>
<pre class=link-defaults>
spec:css-writing-modes-4; type:dfn; text:end
</pre>

<style type="text/css">
	.switch > dt { font: inherit; }
	.cb-example-table {
		border: 1px solid;
		border-collapse: collapse;
		font-size: smaller;
		text-align: center;
		margin: 0 2em;
	}
	.cb-example-table td, .cb-example-table th {
		border: 1px solid;
		padding: 0 3px;
	}
	code span, td span {
		white-space: nowrap;
	}
	.relationship-table {
		border: 1px solid;
		border-collapse: collapse;
		font-size: smaller;
		margin: 0 6em;
	}
	.relationship-table th {
		text-align: center;
		white-space:nowrap;
	}
	.relationship-table td, .relationship-table th {
		border: 1px solid;
		padding: 0 3px;
	}
	h2 dfn, h3 dfn {
		font: inherit;
	}

	table.lpr {
		border-collapse: collapse;
	}
	.lpr td, .lpr th {
		border: 1px solid;
		text-align: center;
	}
	.lpr col {
		background: rgb(221, 238, 255);
		border-right: 2px solid;
		font-weight: bold;
		padding: 0 5px;
	}
	.lpr div {
		font-weight: bold;
		-moz-transform: rotate(-90deg) translatex(-0.5em);
		-ms-transform: rotate(-90deg) translatex(-0.5em);
		-o-transform: rotate(-90deg) translatex(-0.5em);
		-webkit-transform: rotate(-90deg) translatex(-0.5em);
		transform: rotate(-90deg) translatex(-0.5em);
		width: 1.5em;
	}
	.lpr th:first-child {
		border: none;
		background: white;
	}
	.lpr tbody td:first-child {
		font-weight: normal;
	}
	.lpr thead td {
		background: rgb(238, 238, 238);
		font-weight: bold;
		padding: 0 5px;
		vertical-align: bottom;
		white-space: nowrap;
	}
	.lpr thead tr:nth-child(2) {
		border-bottom: 2px solid;
	}

	#abspos-auto ul { list-style-type: none; margin: 0; }
	#abspos-auto caption { caption-side: bottom; }

</style>

<pre class=anchors>
urlPrefix: https://www.w3.org/TR/CSS2/visuren.html; spec: CSS2;
	url: #normal-flow; text: normal flow; type: dfn;
	url: #x1; text: viewport; type: dfn;
urlPrefix: https://www.w3.org/TR/CSS2/visudet.html; spec: CSS2;
	url: #static-position; text: static position; type: dfn;
	url: #static-position; text: static-position containing block; type: dfn;
</pre>

<pre class=link-defaults>
spec: css-align-3; type: value; text: stretch
</pre>

<h2 id="intro">
Introduction</h2>

	<em>This section is not normative.</em>

	默认情况下，
	CSS布局算法会调整盒子尺寸与位置之间关系，
	以避免重叠。

	本规范定义了当我们需要违反这些假定时的几种方式，
	以可以让它们与其他元素重叠的方式来移动元素：

	* [=Relative positioning=], which visually shifts a box relative to its laid-out location.
	* [=Sticky positioning=], which visually shifts a box relative to its laid-out location
		in order to keep it visible when a scrollable ancestor
		would otherwise scroll it out of sight.
	* [=Absolute positioning=], which ignores normal layout entirely,
		pulling the element [=out of flow=] and
		positioning it relative to its [=containing block=]
		with no regard for other content.
	* [=Fixed positioning=], which absolutely positions the box
		and affixes it to the viewport or page frame
		so that it is always visible.

	这些 [=positioning schemes=] 由 'position' property 和 [=inset properties=]控制。
	它们很强大，但也容易被误用。
	With appropriate care,
	they allow many interesting and useful layouts
	that couldn't otherwise be achieved with standard layout rules;
	without, they allow a page to be laid out in an unusable overlapping jumble of content.

<h3 id="placement">
Module Interactions</h3>

	本模块替代、扩展了[[!CSS2]]以下章节中定义的 [=positioning scheme=] 功能：

	<ul>
		<li>
		<a href="https://www.w3.org/TR/CSS2/visuren.html#containing-block">9.1.2 Containing blocks</a>
		<li>
		<a href="https://www.w3.org/TR/CSS2/visuren.html#positioning-scheme">9.3 Positioning schemes</a>
		<li>
		<a href="https://www.w3.org/TR/CSS2/visuren.html#relative-positioning">9.4.3 Relative positioning</a>
		<li>
		<a href="https://www.w3.org/TR/CSS2/visuren.html#absolute-positioning">9.6 Absolute positioning</a>
		<li>
		<a href="https://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo">9.7 Relationships between display, position, and float</a>
		<li>
		<a href="https://www.w3.org/TR/CSS2/visuren.html#comparison">9.8 Comparison of normal flow, floats, and absolute positioning</a>
		<li>
		<a href="https://www.w3.org/TR/CSS2/visudet.html#containing-block-details">10.1 Definition of "containing block"</a>
		<li>
		<a href="https://www.w3.org/TR/CSS2/visudet.html#abs-non-replaced-width">10.3.7 Absolutely positioned, non-replaced elements</a>
		<li>
		<a href="https://www.w3.org/TR/CSS2/visudet.html#abs-replaced-width">10.3.8 Absolutely positioned, replaced elements</a>
		<li>
		<a href="https://www.w3.org/TR/CSS2/visudet.html#abs-non-replaced-height">10.6.4 Absolutely positioned, non-replaced elements</a>
		<li>
		<a href="https://www.w3.org/TR/CSS2/visudet.html#abs-replaced-height">10.6.5 Absolutely positioned replaced elements</a>
	</ul>

	同时它也取代了 [[CSS-LOGICAL-1]] ([[CSS-LOGICAL-1#inset-properties]]) 中对
	'inset*' 属性的定义。

<h3 id="values">
Value Definitions</h3>

	This specification follows the <a href="https://www.w3.org/TR/CSS2/about.html#property-defs">CSS property definition conventions</a> from [[!CSS2]]
	using the <a href="https://www.w3.org/TR/css-values-3/#value-defs">value definition syntax</a> from [[!CSS-VALUES-3]].
	Value types not defined in this specification are defined in CSS Values &amp; Units [[!CSS-VALUES-3]].
	Combination with other CSS modules may expand the definitions of these value types.

	In addition to the property-specific values listed in their definitions,
	all properties defined in this specification
	also accept the <a>CSS-wide keywords</a> as their property value.
	For readability they have not been repeated explicitly.


<h2 id="position-property">
Choosing A Positioning Scheme: 'position' property</h2>

	<pre class="propdef">
	Name: position
	Value: static | relative | absolute | sticky | fixed
	Initial: static
	Applies to: all elements except table-column-group and table-column
	Inherited: no
	Animatable: no
	Percentages: N/A
	Computed value: specified keyword
	Animation type: discrete
	</pre>

	The 'position' property determines which of the <dfn export lt="positioning scheme">positioning schemes</dfn>
	is used to calculate the position of a box.
	Values other than ''static'' make the box a <dfn export lt="positioned box|positioned">positioned box</dfn>,
	and cause it to establish an [=absolute positioning containing block=] for its descendants.
	Values have the following meanings:

<dl dfn-for="position" dfn-type="value">
	<dt><dfn>static</dfn>
	<dd>
		该盒子不是一个 [=positioned box=]，
		它根据父元素的 [=formatting context=]进行布局。
		[=inset properties=] 不能应用到盒子上。

	<dt><dfn>relative</dfn>
	<dd>
		该盒子按照''static''进行布局，然后从布局好的位置进行偏移。
		这种偏移仅仅是视觉上的效果，不会影响其他盒子的尺寸或位置，
		除非它增加了祖先盒子的[=scrollable overflow area=]。
		这种 [=positioning scheme=] 被称为 
		<dfn export dfn for="" lt="relative position | relatively position | relatively-positioned | relatively positioned box" local-lt="relative|relatively">relative positioning</dfn>。

	<dt><dfn>sticky</dfn>
	<dd>
		Identical to ''relative'',
		except that its offsets are automatically adjusted
		in reference to the nearest ancestor [=scroll container's=] [=scrollport=]
		(as modified by the [=inset properties=])
		in whichever axes the [=inset properties=] are not both ''top/auto'',
		to try to keep the box in view within its [=containing block=]
		as the user scrolls.
		This [=positioning scheme=] is called
		<dfn export dfn for="" lt="sticky position | sticky-positioned | sticky-positioned box" local-lt="sticky">sticky positioning</dfn>.

	<dt><dfn>absolute</dfn>
	<dd>
		盒子被taken [=out of flow=]，
		这将使得它对它的兄弟以及祖先盒子的尺寸或位置没有影响，
		而且也不会参与它父亲的 [=formatting context=]。
		相反，盒子的定位与大小仅参考它的 [=absolute positioning containing block=]，
		并由盒子的 [=inset properties=] 进行更改，
		请参见 [[#abspos-layout]]。
		它可以覆盖 [=in-flow=] 内容，
		或其它 [=absolutely positioned=] 元素，
		且它包含在生成包含块的盒子的 [=scrollable overflow area=] 中。
		这种 [=positioning scheme=] 被叫做
		<dfn export dfn for="" lt="absolute position | absolutely position | absolutely-positioned | absolutely positioned box | absolutely positioned element" local-lt="absolute|absolutely">absolute positioning</dfn>。

	<dt><dfn>fixed</dfn>
	<dd>
		与 ''absolute'' 相同，
		除了该盒子是相对于 [=fixed positioning containing block=] （通常是 [=continuous media=] 中的 [=viewport=]，或 [=paged media=]中的 [=page area=]）。
		来进行定位以及调整大小的，
		盒子的位置相对于这个参照矩形来说是固定的：
		当附加到 [=viewport=]、文档发生滚动时，它不会发生移动。
		当附加到 [=page area=]、文档发生分页时，它会在每个页面上复制。
		这种 [=positioning scheme=] 被称为 <dfn export dfn for="" lt="fixed position | fixed-positioned | fixed-positioned box" local-lt="fixed">fixed positioning</dfn>，
		且它被认为是 [=absolute positioning=] 的一个子集。

		<div class="example">
			作者或许期望以一种依赖于媒体的方式来指定 ''fixed''。
			例如，作者期望一个盒子保持在屏幕顶部的 <a>viewport</a>，
			而不是每一个被打印出来的页面上。
			这可以使用 <a href="https://www.w3.org/TR/CSS2/media.html#at-media-rule">'@media'</a> 规则来区分：

			<pre highlight=css>
			@media screen {
					h1#first { position: fixed }
			}
			@media print {
					h1#first { position: static }
			}
			</pre>
		</div>
</dl>

当 'position' 值为 ''position/absolute'' 或 ''position/fixed'' 时，
会 [=blockifies=] 盒子（使得盒子成为一个块级盒子），
并导致 'float' 计算为 ''position/absolute'' 或 ''position/fixed''。

<h3 id="def-cb">
定位盒子的包含块</h3>

	''position/static''、''position/relative'' 或 ''position/sticky'' 盒子的包含块
	由它的 [=formatting context=] 所定义。
	对于 ''position/fixed'' 和 ''position/absolute'' 盒子，则由以下情况来定义：

	<dl class=switch>
		<dt id="absolute-cb">如果盒子具有 ''position: absolute''：
		<dd>
			[=containing block=] 由最近的、
			通过下列方法建立了一个 <dfn export>absolute positioning containing block</dfn> 的
			祖先盒子来建立：

			<dl class=switch>
				<dt>如果祖先不是一个 [=inline box=],
				<dd>
					[=containing block=] 由祖先的 [=padding edge=] 来建立，
					除非另有规定
					（例如，见 [[CSS-GRID-1#abspos-items]]）。

				<dt>如果祖先是一个 [=inline box=]，
				<dd>
					[=containing block=] 由 
					[=block-start=] 祖先
					第一个 [=box fragment=] 的 [=inline-start=] 和 [=block-start=] [=content edges=]
					最后一个 [=box fragment=] 的 [=block-end=] 和 [=inline-end=] [=content edges=] 组成。

					Note: 如果祖先换行，
					“start” 位置或许更比 “end” 位置靠后。
			</dl>

			如果祖先没有建立一个 [=absolute positioning containing block=]，
			则它为 [=initial containing block=]。

			Note: 能够使[=absolute positioning containing block=] 被建立的属性包括了
			'position'、'transform'、'will-change'、'contain' &hellip;

		<dt id="fixed-cb">如果盒子具有 ''position: fixed''：
		<dd>
			[=containing block=] 由最近的、
			建立了一个 <dfn export>fixed positioning containing block</dfn> 的
			祖先盒子来建立，
			[=containing block=] 的确定方式与 [=absolute positioning containing block=] 一致。

			Note: 能够使 [=fixed positioning containing block=] 被建立的属性包括了
			'position'、'transform'、'will-change'、'contain' &hellip;

			如果祖先没有建立一个 [=fixed positioning containing block=]，
			则它为：

			* 在 [=continuous media=]，
				为 <a>viewport</a>；
				最终结果是，[=fixed=] 的盒子在文档发生滚动的时候不会移动。
			
				Note: 这方面与 [[css-backgrounds-3#background-attachment|fixed background images]]
				（''background-attachment: fixed''）相似。

			* 在 [=paged media=]，
				为每页的 [=page area=]；
				[=fixed positioned=] [=boxes=] 在每一页上都被复制一遍。
				（它们仅在对应页面盒子上固定，不受 [=viewport=] 中所看到的影响；
				例如，在打印预览的情况下。）

			Note: 最终结果是，延伸到
			[=initial containing block=] / [=page area=] 外部的部分
			不能被滚动到，而且也将不会被打印。
	</dl>

<div class="example">

	没有定位时，如下文档中：

	<pre highlight=html>
		&lt;!DOCTYPE html>
		&lt;html>
				&lt;head>
						&lt;title>Illustration of containing blocks&lt;/title>
				&lt;/head>
				&lt;body id="body">
						&lt;div id="div1">
						&lt;p id="p1">This is text in the first paragraph...&lt;/p>
						&lt;p id="p2">This is text &lt;em id="em1"> in the
						&lt;strong id="strong1">second&lt;/strong> paragraph.&lt;/em>&lt;/p>
						&lt;/div>
				&lt;/body>
		&lt;/html>
	</pre>

	如下包含块（C.B.）被建立：

	<table class="cb-example-table">
		<tr><th>盒子由……生成 <th>C.B. 由……建立
		<tr><td>html<td>初始 C.B. （取决于UA）
		<tr><td>body<td>html
		<tr><td>div1<td>body
		<tr><td>p1<td>div1
		<tr><td>p2<td>div1
		<tr><td>em1<td>p2
		<tr><td>strong1<td>p2
	</table>

	如果我们定位"div1"：

	<pre highlight=css>
		#div1 { position: absolute; left: 50px; top: 50px }
	</pre>

	它的包含块不再是"body"；
	它的包含块变成了<span>initial containing block</span>
	（因为没有其它被定位的祖先盒子了）。

	如果我们也定位"em1"：

	<pre highlight=css>
		#div1 { position: absolute; left: 50px; top: 50px }
		#em1	{ position: absolute; left: 100px; top: 100px }
	</pre>

	包含块表格将变为：

	<table class="cb-example-table">
		<tr><th>盒子由……生成 <th>C.B. 由……建立
		<tr><td>html<td>初始 C.B. （取决于UA）
		<tr><td>body<td>html
		<tr><td>div1<td>初始 C.B. 
		<tr><td>p1<td>div1
		<tr><td>p2<td>div1
		<tr><td>em1<td>div1
		<tr><td>strong1<td>em1
	</table>

	通过定位 "em1"，它的包含块变成了最近的被定位的祖先盒子
	（也就是由"div1"生成的盒子）。
</div>


<h2 id="coords">
定位坐标</h2>

	[=positioned box=] 的精确位置由
	<dfn>inset properties</dfn> 控制：
	[=physical=] [=inset properties=]：'top'、'right'、'bottom'、'left'；
	[=flow-relative=] [=inset properties=]：'inset-block-start'、'inset-inline-start'、'inset-block-end' 和 'inset-inline-end'；
	以及它们的 [=shorthands=]：'inset-block'、'inset-inline' 和 'inset'。

	这些 [=inset properties=] 的解释因 [=positioning scheme=] 而异：

	* 对于 [=absolute positioning=]，
		这些属性表示来自包含块的inset。
	* 对于 [=relative positioning=]，
		这些属性表示来自盒子原始留白边缘的inset。
	* 对于 [=sticky positioning=]，
		这些属性表示来自[=scrollport=]边缘的inset。

<h3 id="insets">
Box Insets: the 'top', 'right', 'bottom', 'left', 'inset-block-start', 'inset-inline-start', 'inset-block-end', and 'inset-inline-end' properties </h3>

	<pre class="propdef">
	Name: top, right, bottom, left, inset-block-start, inset-inline-start, inset-block-end, inset-inline-end
	Value: auto | <<length-percentage>>
	Initial: auto
	Applies to: positioned elements
	Inherited: no
	Percentages: refer to size of <a>containing block</a>; see prose
	Computed value: the keyword ''top/auto'' or a computed <<length-percentage>> value
	Animation type: by computed value type
	</pre>

	These [=inset properties=] represent an inward “inset”
	on the corresponding side of the box
	(with respect to the box’s own [=writing mode=];
	see [[CSS-WRITING-MODES-3#abstract-box]]).
	For example, 'top' represents a downward inset of the top edge.
	The [=physical=] and [=flow-relative=] properties
	interact as defined in [[!CSS-LOGICAL-1]].
	Values have the following meanings:

	<dl dfn-for="top,right,bottom,left, inset-block-start,inset-inline-start,inset-block-end,inset-inline-end inset-block,inset-inline,inset" dfn-type="value">
		<dt><dfn>&lt;length></dfn>
		<dd>
			The inset is a fixed distance from the reference edge.
			Negative values are allowed.

		<dt><dfn>&lt;percentage></dfn>
		<dd>
			The inset is a percentage
			relative to the <a>containing block</a>’s size
			in the corresponding axis
			(e.g. width for 'left' or 'right', height for 'top' and 'bottom').
			For [=sticky positioned=] boxes,
			the inset is instead
			relative to the relevant [=scrollport=]’s size.
			Negative values are allowed.

		<dt><dfn>auto</dfn></dt>
		<dd>
			Represents an unconstrained inset;
			the exact meaning depends on the [=positioning scheme=].
	</dl>

	Note: For [=fixed positioned=] elements,
	using large values or negative values
	can easily move elements outside the <a>viewport</a>
	and make the contents unreachable through scrolling or other means.

<h3 id="inset-shorthands">
Box Insets Shorthands: the 'inset-block', 'inset-inline', and 'inset' properties</h3>

	<pre class="propdef">
	Name: inset-block, inset-inline
	Value: <'top'>{1,2}
	Initial: auto
	Applies to: positioned elements
	Inherited: no
	Percentages: see individual properties
	Computed value: see individual properties
	Animation type: by computed value type
	</pre>

	The 'inset-block' and 'inset-inline' properties are [=shorthand properties=]
	for setting 'inset-block-start' + 'inset-block-end'
	or 'inset-inline-start' + 'inset-inline-end',
	respectively,
	in a single declaration.
	The first component value sets the [=CSS/start=] side,
	the second sets the [=CSS/end=];
	if omitted, the second value defaults to the first.

	<pre class="propdef">
	Name: inset
	Value: <'top'>{1,4}
	Initial: auto
	Applies to: positioned elements
	Inherited: no
	Percentages: see individual properties
	Computed value: see individual properties
	Animation type: by computed value type
	</pre>

	The 'inset' property is a [=shorthand property=]
	that sets all of the [=inset properties=]
	in a single declaration,
	assigning values to the longhands representing each side
	exactly as the 'margin' property does for its longhands.

	<div class=note>

		By default, the 'inset' property values
		are assigned to the corresponding <em>[=physical=]</em> [=longhand properties=]--
		'top', 'right', 'bottom', and 'left'--
		which for historical reasons do not have an <css>inset-</css> prefix.
		This matches the behavior of other "4 values assigned to sides" properties,
		such as 'margin'.

		Allowing properties such as this to resolve to the [=flow-relative=] [=longhands=] is under discussion in [[CSS-LOGICAL-1]].

		Yes, we understand it's a little confusing
		that 'inset' doesn't expand to any 'inset-*' properties.
	</div>



<h3 id="relpos-insets" oldids="relpos">
相对定位</h3>

	对于 [=relatively positioned=] 盒子，
	[=inset properties=] 沿着相应边缘向内移动，
	而不会改变盒子的尺寸。
	'left' 将盒子右移，'right' 将盒子左移，诸如此类。
	由于 [=relative positioning=] 不会拆分或拉伸盒子，
	因此给定轴上相反的 [=used values=] 必须相互否定：

	<ul>
		<li>
			如果在一个轴上，两个相反的 [=inset properties=] 都被计算为 ''top/auto''（初始值），
			它们 [=used values=] 将是 0
			（即盒子在该轴上保持原位）

		<li>
			如果其中一个是 ''top/auto''，
			它 [=used value=] 将会是另一个的否定值，
			盒子将会按照给定数量进行移动。

		<li>
			如果没有任何一个是 ''top/auto''，
			那么位置就过度约束了；
			（相对于它 [=containing block=] 的 [=writing mode=]）
			[=computed value|computed=] [=CSS/end=] 端值将被忽略，
			它 [=used value=] 将会是 [=CSS/start=] 端的否定值。
	</ul>


	<div class="example">

		下列三个规则是相等的，
		都会将盒子向左移动 ''1em''：

		<pre highlight=css>
		div.a8 { position: relative; direction: ltr; left: -1em; right: auto }
		div.a8 { position: relative; direction: ltr; left: auto; right: 1em }
		div.a8 { position: relative; direction: ltr; left: -1em; right: 5em }
		</pre>
	</div>

	If specified on
	a ''table-row-group'', ''table-header-group'', ''table-footer-group'', or ''table-row'' [=box=]
	the shift affects all the contents of the box,
	including all <a value lt="table-cell">table cells</a> that originate in the affected row,
	but not those that don't.

	Note: Since 'position' does not apply to ''table-column-group'' or ''table-column'' boxes,
	they are not affected by [=relative positioning=].



<h3 id="stickypos-insets" oldids="sticky-pos">
Sticky positioning</h3>

	[=Sticky positioning=] is similar to [=relative positioning=]
	except the offsets are automatically calculated
	in reference to the [=nearest scrollport=].

	For a [=sticky positioned=] [=box=],
	the [=inset properties=]
	represent insets from the respective edges of the [=nearest scrollport=],
	defining the <dfn export>sticky view rectangle</dfn>
	used to constrain the box’s position.
	(For this purpose an ''top/auto'' value represents a zero inset.)
	If this results in a [=sticky view rectangle=] size in any axis
	less than the size of the [=border box=] of the [=sticky=] box in that axis,
	then the effective [=end=]-edge inset in the affected axis is reduced
	(possibly becoming negative)
	to bring the [=sticky view rectangle=]’s size up to
	the size of the [=border box=] in that axis
	(where [=end=] is interpreted relative to the [=writing mode=] of the [=containing block=]).

	<div class=example>
		For example,
		if the [=nearest scrollport=] is ''300px'' tall,
		the [=sticky=] box's [=border box=] is ''200px'' tall,
		and it has ''top: 20px'',
		then the top-edge inset of the [=nearest scrollport=] is ''20px'',
		and the bottom-edge inset is ''0px'',
		yielding a [=sticky view rectangle=] that is ''280px'' tall.

		But if the [=nearest scrollport=] were only ''100px'' tall,
		then the effective bottom-edge inset becomes ''-120px'',
		resulting in a [=sticky view rectangle=] that’s ''200px'' tall,
		enough to fully contain the [=margin box=] of the [=sticky=] box.
	</div>

	For each side of the box,
	if the corresponding [=inset property=] is not ''top/auto'',
	and the corresponding [=border edge=] of the box would be outside
	the corresponding edge of the [=sticky view rectangle=],
	then the box must be visually shifted
	([[#relpos-insets|as for relative positioning]])
	to be inward of that [=sticky view rectangle=] edge,
	insofar as it can while its [=position box=]
	remains contained within its [=containing block=].
	The <dfn>position box</dfn> is its [=margin box=],
	except that for any side for which the distance between its [=margin edge=]
	and the corresponding edge of its [=containing block=]
	is less than its corresponding [=margin=],
	that distance is used in place of that [=margin=].

	Note: A sticky positioned element with
	a non-''auto'' 'top' value and an ''auto'' 'bottom' value
	will only ever be pushed down by sticky positioning;
	it will never be offset upwards.

	Note: Multiple [=sticky positioned=] boxes in the same container
	are offset independently,
	and therefore might overlap.

<h4 id="stickypos-scroll">
Scroll Position of Sticky-Positioned Boxes</h4>

	For the purposes of any operation targeting the scroll position
	of a sticky positioned element (or one of its descendants),
	the sticky positioned element must be considered to be positioned
	at its initial (non-offsetted) position.

	<div class="example">
		For example, if a user clicks a link targeting a [=sticky-positioned=] element,
		even if the element's [=nearest scrollport=] is currently scrolled
		such that the [=sticky positioned=] element is offset from its initial position,
		the [=scrollport=] will be scrolled back
		so that the element's initial position is visible.
	</div>


<h3 id="abspos-insets" oldids="abs-pos,fixed-pos">
绝对（以及固定）定位</h3>

	对于一个 [=absolutely positioned=] 盒子，
	[=inset properties=] 有效地减少了 [=containing block=]，
	它被调整大小和定位到指定数量。

	如果在给定轴上仅有一个 [=inset property=] 值为 ''top/auto''，
	那么它的值为0。
	如果在给定轴上，两个 [=inset properties=] 都是 ''top/auto''，那么，
	将取决于在对应轴上盒子的 [=self-alignment property=]：

	<dl class=switch>
		<dt>for ''align-self/self-start'' alignment or its equivalent
		<dd>
			Set its start-edge [=inset property=] to the static position,
			and its end-edge [=inset property=] to zero.

		<dt>for ''align-self/self-end'' alignment or its equivalent
		<dd>
			Set its end-edge [=inset property=] to the static position,
			and its start-edge [=inset property=]  to zero.

		<dt>for ''align-self/center'' alignment
		<dd>
			Let <var>start distance</var> be the distance from
			the center of its [=static position rectangle=]
			to the start edge of its [=containing block=],
			and <var>end distance</var> be the distance from
			the center of its [=static position rectangle=]
			to the end edge of its [=containing block=].
			If <var>start distance</var> is less than or equal to <var>end distance</var>,
			then set the start-edge [=inset property=] to zero,
			and set the end-edge [=inset property=] to
			(<var>containing block size</var> - 2 &times; |<var>start distance</var>|);
			otherwise,
			set the end-edge [=inset property=] to zero
			and the start-edge [=inset property=] to
			(<var>containing block size</var> - 2 &times; |<var>end distance</var>|).
	</dl>

	If these adjustments result in
	an effective [=containing block=] size in any axis less than zero,
	then the [=weaker inset=] in the affected axis
	is reduced (possibly becoming negative)
	to bring that size up to zero.
	In the case that only one inset is ''auto'',
	that is the <dfn>weaker inset</dfn>;
	otherwise the [=weaker inset=] is the inset of the [=end=] edge
	(where [=end=] is interpreted relative to the [=writing mode=] of the [=containing block=]).

	Note: Sizing and positioning of the [=absolutely positioned box=]
	into this <dfn>inset-modified containing block</dfn>
	is as described in [[#abspos-layout]].

	If its [=self-alignment property=] in an axis is ''align-self/normal'',
	then the [=resolved value=] of its [=weaker inset=] in that axis
	is the value necessary to match that edge of its [=inset-modified containing block=]
	to the corresponding edge of its [=margin box=]
	after [[#abspos-layout|layout]].
	(Otherwise the [=resolved value=] is the [=used value=] described above.)


<h4 id="staticpos-rect">
Resolving Automatic Insets</h4>

	When both [=inset properties=] in a given axis are ''left/auto'',
	they are resolved in reference to the box’s <dfn export>static position rectangle</dfn>,
	whose edges represent the [=static position=] of the box
	from each side of its [=containing block=].
	This [=static position rectangle=]
	and the [=static positions=] to which it corresponds
	are defined by the layout model
	the box would have had if its 'position' were ''position/static''
	(and its 'float' and 'clear' values were ''float/none'').
	(Note that this may require assuming a different hypothetical value
	for 'display' as well.)

	<dl>
		<dt>Block Layout
		<dd>
			The [=static positions=] of a [=block-level box=]
			are defined in [[CSS2]] Chapter 10.
			The [=static position rectangle=] is a zero-thickness rectangle spanning between
			the inline-axis sides of the box’s [=static-position containing block=]
			(see <a href="https://www.w3.org/TR/CSS2/visudet.html#abs-non-replaced-width">CSS2&sect;10.3.7</a>);
			and positioned at its [=block-start=] [=static position=]
			(see <a href="https://www.w3.org/TR/CSS2/visudet.html#abs-non-replaced-height">CSS2&sect;10.6.4</a>).

		<dt>Inline Layout
		<dd>
			The [=static positions=] of an [=inline-level box=]
			are defined in [[CSS2]] Chapter 10.
			The [=static position rectangle=] is a zero-thickness rectangle spanning between
			the [=line-over=]/[=line-under=] sides of the [=line box=]
			that would have contained its “hypothetical box”
			(see <a href="https://www.w3.org/TR/CSS2/visudet.html#abs-non-replaced-width">CSS2&sect;10.3.7</a>);
			and positioned at its [=inline-start=] [=static position=].

		<dt>Flex Layout
		<dd>
			The [=static position rectangle=] of the child of a [=flex container=]
			corresponds to the [=content edges=] of the [=flex container=].
			See <a href="https://www.w3.org/TR/css-flexbox-1/#abspos-items">static position of a grid container child</a> in [[!CSS-FLEXBOX-1]].

		<dt>Grid Layout
		<dd>
			By default, the [=static position rectangle=] of the child of a [=grid container=]
			corresponds to the [=content edges=] of the [=grid container=].
			However, if that [=grid container=] also establishes
			the box’s actual [=containing block=],
			then the [=grid area=] specified by the [=grid-placement properties=]
			establishes its [=static position rectangle=] instead.
			See the <a href="https://www.w3.org/TR/css-grid-1/#static-position">static position of a grid container child</a> in [[!CSS-GRID-1]].
	</dl>

	For the purposes of calculating the [=static position rectangle=],
	the [=containing block=] of [=fixed positioned=] elements
	is the [=initial containing block=] instead of the [=viewport=],
	and all [=scroll containers=] should be assumed
	to be scrolled to their [=initial scroll position=].
	Additionally, all ''margin/auto'' margins on the box itself
	are treated as zero.

<h4 id="abspos-breaking" oldids="breaking">
Fragmenting Absolutely-positioned Elements</h4>

	In a [=fragmented flow=], an [=absolutely positioned box=]
	is positioned relative to its [=containing block=]
	ignoring any [=fragmentation breaks=]
	(as if the flow were continuous).
	The box may subsequently be broken over several [=fragmentation containers=].

	For absolutely positioned content in [=paged media=]
	that resolves to a position on a page
	other than the page being laid out (the current page),
	or resolves to a position on the current page
	that has already been rendered for printing,
	printers may place the content:

	<ul>
		<li>on the current page,
		<li>on a subsequent page, or
		<li>may omit it altogether.
	</ul>

	Note: A [=block-level=] element that is split over several pages
	can have a different width on each page,
	and there may be device-specific limits.

	User agents must not paginate the content of [=fixed-positioned boxes=].

	Note: User agents might print invisible content in other ways.
	See [[CSS-PAGE-3#content-outside-box]].

<h2 id="abspos-layout">
Absolute Positioning Layout Model</h2>

	[=Absolute positioning=] not only takes a box [=out of flow=],
	but also lays it out in its [=containing block=]
	(after the final size of the [=containing block=] has been determined)
	according to the <dfn export lt="absolute positioning layout | absolute positioning layout model">absolute positioning layout model</dfn>:

	<ol>
		<li>
			First, its [=inset-modified containing block=] is calculated,
			defining its [=available space=].
			(See [[#abspos-insets]].)
			Because an [=absolutely positioned box=] can have no effect on the size of its [=containing block=],
			its [=available space=] is always [=definite=].
		<li>
			Next, its width and height are resolved against this [=definite=] [=available space=],
			as its [=preferred size=] capped by its [=maximum size=] (if any), floored by its [=minimum size=].
			See [[#abspos-auto-size]].
			Percentages, however,
			are resolved against the original [=containing block=] size.

		<li>
			Then, the value of any ''margin/auto'' margins are calculated,
			see [[#abspos-margins]].

		<li>
			Lastly, its [=margin box=] is aligned within the [=inset-modified containing block=]
			as defined by its [=self-alignment properties=].
	</ol>

<h3 id="abspos-auto-size">
Automatic Sizes of Absolutely-Positioned Boxes</h3>

	The [=automatic size=] of an [=absolutely positioned box=] is resolved against its [=inset-modified containing block=] as follows
	(treating ''margin/auto'' [=margins=] as zero):

	<dl class=switch>
		: If its [=self-alignment property=] in the relevant axis is ''align-self/stretch''
		: If it is ''align-self/normal''
			and the box is [=non-replaced=]
			and has no ''inset/auto'' [=inset property|inset=] in the relevant axis
		::
			Its [=automatic size=] is its [=stretch-fit size=].

		: If its [=self-alignment property=] in the relevant axis is not ''align-self/stretch''
		: If it is ''align-self/normal''
			and the box is [=replaced=]
		: If it is ''align-self/normal''
			and has at least one ''inset/auto'' [=inset property|inset=] in the relevant axis
		::
			Its [=automatic size=] is its [=fit-content size=].
	</dl>

	However, if the box has an aspect-ratio,
	then an [=automatic size=] in the [=ratio-dependent axis=]
	is instead resolved as a [=max-content size=].
	When both axes have an [=automatic size=],
	if only one axis has an ''inset/auto'' [=inset property|inset=]
	then that axis is the [=ratio-dependent axis=],
	else the [=block axis=] is the [=ratio-dependent axis=].
	An [=automatic size=] in the [=ratio-determining axis=]
	is determined as above.

	The [=automatic minimum size=] of an absolutely-positioned box is always zero.

<h3 id="abspos-margins">
Auto Margins of Absolutely-Positioned Boxes</h3>

	If either [=inset property=] in the relevant axis is ''top/auto'',
	then any ''margin/auto'' [=margins=] resolve to zero.

	Otherwise, the <var>remaining space</var> is calculated
	as the size of its [=inset-modified containing block=] in the relevant axis
	minus the box's used size in the relevant axis,
	and this <var>remaining space</var> is divided among
	any ''margin/auto'' margins in the relevant axis.
	However,
	(all with respect to the [=writing mode=] of the [=containing block=]),
	if in the [=inline axis=]
	the <var>remaining space</var> is negative
	and both margins are ''margin/auto'',
	the [=inline-start|start=] margin resolves to zero
	and the [=inline-end|end=] margin receives the <var>remaining space</var>.

<h2 id="abspos-old">
过时的绝对定位布局模型</h2>

	ISSUE: 本章节已被新的 [[#abspos-layout]] 所取代。
	保留于此用以对比：
	
	both models should yield the same result
	in [=horizontal writing modes=] when the box’s [=self-alignment=] is ''align-self/normal''.

<h3 id="abs-non-replaced-width">
The Width of Absolutely-Positioned, Non-Replaced Elements</h3>

	The constraint that determines the used values for these elements is:

	<code>
		'left' + 'margin-left' + 'border-left-width' + 'padding-left' + 'width' +
		'padding-right' + 'border-right-width' + 'margin-right' +
		'right' = width of containing block
 </code>

	If all three of 'left', 'width', and 'right' are ''left/auto'':
	First set any ''margin/auto'' values for 'margin-left' and 'margin-right'
	to ''0''.
	Then, if the 'direction' property of
	the element establishing the static-position <a>containing block</a>
	is ''ltr'' set 'left' to the static position
	and apply rule number <em>three</em> below;
	otherwise, set 'right' to the static-position
	and apply rule number <em>one</em> below.

	If none of the three is ''left/auto'':
	If both 'margin-left' and 'margin-right' are ''margin/auto'',
	solve the equation under the extra constraint that
	the two margins get equal values,
	unless this would make them negative,
	in which case when direction of the containing block is ''ltr'' (''rtl''),
	set 'margin-left' ('margin-right') to ''0''
	and solve for 'margin-right' ('margin-left').
	If one of 'margin-left' or 'margin-right' is ''margin/auto'',
	solve the equation for that value.
	If the values are over-constrained,
	ignore the value for 'left'
	(in case the 'direction' property of the <a>containing block</a> is ''rtl'')
	or 'right'
	(in case 'direction' is ''ltr'') and solve for that value.

	Otherwise,
	set ''margin/auto'' values for 'margin-left' and 'margin-right' to ''0'',
	and pick one of the following six rules that apply.

	<ol>
		<li>
		If 'left' and 'width' are ''left/auto'' and 'right' is not ''right/auto'',
		then the width is shrink-to-fit.
		Then solve for 'left'.

		<li>
		If 'left' and 'right' are ''left/auto'' and 'width' is not ''width/auto'',
		then if the 'direction' property of
		the element establishing the static-position <a>containing block</a>
		is ''ltr''
		set 'left' to the static-position,
		otherwise set 'right' to the static-position.
		Then solve for 'left' (if 'direction' is ''rtl'')
		or 'right' (if 'direction' is ''ltr'').

		<li>
		If 'width' and 'right' are ''width/auto'' and 'left' is not ''left/auto'',
		then the width is shrink-to-fit.
		Then solve for 'right'.

		<li>
		If 'left' is ''left/auto'', 'width' and 'right' are not ''width/auto'',
		then solve for 'left'.

		<li>
		If 'width' is ''width/auto'', 'left' and 'right' are not ''left/auto'',
		then solve for 'width'.

		<li>
		If 'right' is ''right/auto'', 'left' and 'width' are not ''left/auto'',
		then solve for 'right'.
	</ol>

<table class=data id='abspos-auto'>
	<caption>
		Summary of rules for <code>dir=ltr</code> in horizontal writing modes
	</caption>
	<colgroup span=5></colgroup>
	<colgroup span=1></colgroup>
	<thead>
		<tr>
			<th colspan=5>Is auto?
			<th rowspan=2>Result
		<tr>
			<th>'left'
			<th>'width'
			<th>'right'
			<th>'margin-left'
			<th>'margin-right'
	<tbody>
		<tr>
			<td>✔
			<td>✔
			<td>✔
			<td colspan=2>any
			<td>
				<ul>
					<li>auto margins → zero
					<li>left → static pos
					<li>width → shrink-to-fit
					<li>right → solve
				</ul>
		<tr>
			<td rowspan=4>✘
			<td rowspan=4>✘
			<td rowspan=4>✘
			<td>✔
			<td>✘
			<td rowspan=2>
				auto margin → free space
		<tr>
			<td>✘
			<td>✔
		<tr>
			<td>✔
			<td>✔
			<td>
				<ul>
					<li>margins split positive free space
					<li>right margin gets negative free space
				</ul>
		<tr>
			<td>✘
			<td>✘
			<td>
				treat 'right' as ''right/auto''
		<tr>
			<td>✔
			<td>✘
			<td>✔
			<td colspan=2>any
			<td>
				<ul>
					<li>auto margins → zero
					<li>left → static pos
					<li>width → as specified
					<li>right → solve
				</ul>
		<tr>
			<td>✔
			<td>✔
			<td>✘
			<td colspan=2>any
			<td>
				<ul>
					<li>auto margins → zero
					<li>left → solve
					<li>width → shrink-to-fit
					<li>right → as specified
				</ul>
		<tr>
			<td>✘
			<td>✔
			<td>✔
			<td colspan=2>any
			<td>
				<ul>
					<li>auto margins → zero
					<li>left → as specified
					<li>width → shrink-to-fit
					<li>right → solve
				</ul>
		<tr>
			<td>✔
			<td>✘
			<td>✘
			<td colspan=2 rowspan=3>any
			<td rowspan=3>
				<ul>
					<li>auto margins → zero
					<li>solve for auto
				</ul>
		<tr>
			<td>✘
			<td>✘
			<td>✔
		<tr>
			<td>✘
			<td>✔
			<td>✘
</table>


<h3 id="abs-replaced-width">
The width of absolute or fixed positioned, replaced elements</h3>

	If 'height' and 'width' both have computed values of <css>auto</css>
	and the element also has an intrinsic width,
	then that intrinsic width is the used value of 'width'.

	If 'height' and 'width' both have computed values of <css>auto</css>
	and the element has no intrinsic width,
	but does have an intrinsic height and intrinsic ratio;
	or if 'width' has a computed value of <css>auto</css>,
	'height' has some other computed value,
	and the element does have an intrinsic ratio;
	then the used value of 'width' is:

	<code>(used height) * (intrinsic ratio)</code>

	If 'height' and 'width' both have computed values of <css>auto</css>,
	the element has an intrinsic ratio but no intrinsic height or width,
	and the <a>containing block’s</a> width
	does not itself depend on the replaced element’s width,
	then the used value of 'width' is calculated
	from the constraint equation used for
	<a href="https://www.w3.org/TR/CSS21/visudet.html#blockwidth">block-level, non-replaced elements in <a>normal flow</a></a>.

	Otherwise, if 'width' has a computed value of <css>auto</css>,
	and the element has an intrinsic width,
	then that intrinsic width is the used value of 'width'.

	Otherwise, if 'width' has a computed value of <css>auto</css>,
	but none of the conditions above are met,
	and then the used value of 'width' becomes ''300px''.
	If ''300px'' is too wide to fit the device,
	user agents should use the width of the largest rectangle
	that has a 2:1 ratio and fits the device instead.

	After establishing the 'width',
	in order to position the replaced element,
	apply the following rules as appropriate.

	<ol>
		<li>
		If both 'left' and 'right' have the value <css>auto</css>,
		and if the 'direction' property of
		the element establishing the static-position <a>containing block</a>
		is ''ltr'',
		set 'left' to the static position and solve for 'right';
		else if 'direction' is ''rtl'',
		set 'right' to the static position and solve for 'left'.

		<li>
		If 'left' is <css>auto</css> and 'right' is not <css>auto</css>,
		replace any <css>auto</css> on 'margin-left' or 'margin-right'
		with ''0'',
		then solve for 'left'.

		<li>
		If 'right' is <css>auto</css> and 'left' is not <css>auto</css>,
		replace any <css>auto</css> on 'margin-left' or 'margin-right'
		with ''0'',
		then solve for 'right'.

		<li>
		If at this point both 'margin-left' and 'margin-right'
		are still <css>auto</css>,
		solve the equation under the extra constraint
		that the two margins must get equal values,
		unless this would make them negative,
		in which case when the direction of the <a>containing block</a>
		is ''ltr'' (''rtl''),
		set 'margin-left' ('margin-right') to ''0''
		and solve for 'margin-right' ('margin-left').

		<li>
		If at this point there is an <css>auto</css> remaining,
		solve the equation for that value.

		<li>
		If at this point the values are over-constrained,
		ignore the value for either 'left'
		(in case the 'direction' property of the <a>containing block</a> is ''rtl'')
		or 'right' (in case 'direction' is ''ltr'')
		and solve for that value.
	</ol>

<h3 id="abs-non-replaced-height">
The Height Of Absolutely Positioned, Non-Replaced Elements</h3>

	For absolutely positioned elements,
	the used values of the vertical dimensions
	must satisfy this constraint:

	<code>
		'top' + <span>'margin-top'</span> + <span>'border-top-width'</span> + <span>'padding-top'</span> + 'height' +
		<span>'padding-bottom'</span> + <span>'border-bottom-width'</span> + <span>'margin-bottom'</span> + 'bottom'
		= <span>height of containing block</span>
	</code>

	If all three of 'top', 'height', and 'bottom' are ''top/auto'':
	First set any ''top/auto'' values for 'margin-top' and 'margin-bottom' to ''0'',
	then set 'top' to the static position,
	and finally apply rule number <em>three</em> below.

	If none of the three are ''top/auto'':
	If both 'margin-top' and 'margin-bottom' are ''top/auto'',
	solve the equation under the extra constraint that the two margins get equal values.
	If one of 'margin-top' or 'margin-bottom' is ''top/auto'',
	solve the equation for that value.
	If the values are over-constrained,
	ignore the value for 'bottom' and solve for that value.

	Otherwise,
	set ''top/auto'' values for 'margin-top' and 'margin-bottom' to ''0'',
	and pick one of the following six rules that apply.

	1. If 'top' and 'height' are ''top/auto''
		and 'bottom' is not ''top/auto'',
		then the height is based on the
		<a href="https://www.w3.org/TR/CSS2/visudet.html#root-height">Auto heights for block formatting context roots</a>,
		and solve for 'top'.

	2. If 'top' and 'bottom' are ''top/auto''
		and 'height' is not ''top/auto'',
		then set 'top' to the static position,
		then solve for 'bottom'.

	3. If 'height' and 'bottom' are ''top/auto''
		and 'top' is not ''top/auto'',
		then the height is based on the
		<a href="https://www.w3.org/TR/CSS2/visudet.html#root-height">Auto heights for block formatting context roots</a>,
		and solve for 'bottom'.

	4. If 'top' is ''top/auto'',
		'height' and 'bottom' are not ''top/auto'',
		then solve for 'top'.

	5. If 'height' is ''top/auto'',
		'top' and 'bottom' are not ''top/auto'',
		then solve for 'height'.

	6. If 'bottom' is ''top/auto'',
		'top' and 'height' are not ''top/auto'',
		then solve for 'bottom'.

<h3 id="abs-replaced-height">
The Height Of Absolutely Positioned, Replaced Elements</h3>

	If 'height' and 'width' both have computed values of ''top/auto''
	and the element also has an intrinsic height,
	then that intrinsic height is the used value of 'height'.

	Otherwise, if 'height' has a computed value of ''top/auto''
	and the element has an intrinsic ratio
	then the used value of 'height' is:

	<code>(used width) / (intrinsic ratio)</code></p>

	Otherwise, if 'height' has a computed value of ''top/auto''
	and the element has an intrinsic height,
	then that intrinsic height is the used value of 'height'.

	Otherwise, if 'height' has a computed value of ''top/auto'',
	but none of the conditions above are met,
	then the used value of 'height' must be set to
	the height of the largest rectangle that has a 2:1 ratio,
	has a height not greater than ''150px'',
	and has a width not greater than the device width.

	After establishing the 'height',
	in order to position the replaced element,
	apply the following rules as appropriate.

	1. If both 'top' and 'bottom' have the value ''top/auto'',
		replace 'top' with the element’s static position.

	2. If 'bottom' is ''top/auto'',
		replace any ''top/auto'' on 'margin-top' or 'margin-bottom'
		with ''0''.

	3. If at this point both 'margin-top' and 'margin-bottom' are still ''top/auto'',
		solve the equation under the extra constraint
		that the two margins must get equal values.

	4. If at this point there is only one ''top/auto'' remaining,
		solve the equation for that value.

	5. If at this point the values are over-constrained,
		ignore the value for 'bottom' and solve for that value.

<h2 id="comparison">
Informative Comparison of Normal Flow, Floats, and Positioning</h2>

	<em>This section is not normative.</em>

	To illustrate the differences between <a>normal flow</a>,
	[=relative positioning=], [=floats=], and [=absolute positioning=],
	we provide a series of examples based on the following HTML:

	<div class="example">
		<pre class="lang-html">
		&lt;!DOCTYPE html>
		&lt;html>
				&lt;head>
						&lt;title>Comparison of positioning schemes&lt;/title>
						&lt;style>
							body { display: block; font-size:12px; line-height: 200%;
											width: 400px; height: 400px }
							p		{ display: block }
							span { display: inline }
						&lt;/style>
				&lt;/head>
				&lt;body>
				&lt;p>
						Beginning of p contents.
						&lt;span id="outer"> Start of outer contents.
						&lt;span id="inner"> Inner contents.&lt;/span>
						End of outer contents.&lt;/span>
						End of p contents.
				&lt;/p>
				&lt;/body>
		&lt;/html>
		</pre>
	</div>

	The final positions of boxes generated by the <em>outer</em> and <em>inner</em>
	elements vary in each example. In each illustration, the numbers to the left of
	the illustration indicate the <a>normal flow</a> position of the
	double-spaced (for clarity) lines.

	Note: The diagrams in this section are illustrative and not to scale. They are
	meant to highlight the differences between the various <a>positioning
	schemes</a>, and are not intended to be reference renderings of the
	examples given.

<h3 id="comp-normal-flow">
Normal Flow Example</h3>

	Consider the following CSS declarations for <em>outer</em> and <em>inner</em>
	that do not alter the <a>normal flow</a> of boxes:

	<div class="example">
		<pre class="lang-css">
			#outer { color: red }
			#inner { color: blue }
		</pre>
	</div>

	The P element contains all inline content: <a href="https://www.w3.org/TR/CSS2/visuren.html#anonymous">anonymous inline text</a> and
	two SPAN elements. Therefore, all of the content will be laid out in an inline
	formatting context, within a <a>containing block</a> established by the P element, producing
	something like:

<figure>
	<img src="images/flow-generic.png" alt="Image illustrating the normal flow of text between parent and sibling boxes.">
	<figcaption>
		All of the text within the P's containing block flows together as continuous text,
		even though it's located in separated nested elements.
	</figcaption>
</figure>

<h3 id="comp-relpos">
Relative Positioning Example</h3>

	To see the effect of <a>relative positioning</a>,
	we specify:

	<div class="example">
		<pre class="lang-css">
		#outer { position: relative; top: -12px; color: red }
		#inner { position: relative; top: 12px; color: blue }
		</pre>
	</div>

	Text flows normally up to the <em>outer</em> element. The <em>outer</em> text is
	then flowed into its <a>normal flow</a> position and dimensions at the end of line 1. Then,
	the inline boxes containing the text (distributed over three lines) are shifted as a
	unit by ''-12px'' (upwards).

	The contents of <em>inner</em>, as a child of <em>outer</em>, would normally flow
	immediately after the words "of outer contents" (on line 1.5). However, the <em>inner</em>
	contents are themselves offset relative to the <em>outer</em> contents by ''12px''
	(downwards), back to their original position on line 2.

	<p class="note">
		Note that the content following <em>outer</em> is not affected by the relative
		positioning of <em>outer</em>.
	</p>

	<figure>
		<img src="images/flow-relative.png">
		<figcaption>
			The result is identical to normal flow,
			except that the "outer" text is shifted 12px upward,
			without affecting the flow of the "body" or "inner" text.
		</figcaption>
	</figure>

	<p class="note">
		Note also that had the offset of <em>outer</em> been ''-24px'', the text	of <em>outer</em>
		and the body text would have overlapped.
	</p>

<h3 id="comp-floating">
Floating Example</h3>

	Now consider the effect of <a href="https://www.w3.org/TR/CSS2/visuren.html#floats">
	floating</a> the <em>inner</em> element’s text to the right by means of the
	following rules:

	<div class="example">
		<pre class="lang-css">
		#outer { color: red }
		#inner { float: right; width: 130px; color: blue }
		</pre>
	</div>

	Text flows normally up to the <em>inner</em> box, which is pulled out of the flow
	and <a>floated</a> to the right margin (its 'width' has been
	assigned explicitly). Line boxes to the left of the float are shortened, and the
	document’s remaining text flows into them.

<figure>
	<img src="images/flow-float.png" alt="Image illustrating the effects of floating a box.">
	<figcaption>
		The "inner" text lays out in an independent box on the right,
		causing the remaining "body" and "outer" text to flow around it.
	</figcaption>
</figure>

	To show the effect of the 'clear' property, we add a <em>sibling</em> element to the
	example:

	<div class="example">
		<pre class="lang-html">
		&lt;!DOCTYPE html>
		&lt;html>
				&lt;head>
						&lt;title>Comparison of positioning schemes II&lt;/title>
						&lt;style>
							#inner { float: right; width: 130px; color: blue }
							#sibling { color: red }
						&lt;/style>
				&lt;/head>
				&lt;body>
				&lt;p>
						Beginning of p contents.
						&lt;span id="outer"> Start of outer contents.
						&lt;span id="inner"> Inner contents.&lt;/span>
						&lt;span id="sibling"> Sibling contents.&lt;/span>
						End of outer contents.&lt;/span>
						End of p contents.
				&lt;/p>
				&lt;/body>
		&lt;/html>
		</pre>
	</div>

	These styles cause the <em>inner</em> box to float to the right, as before,
	and the document’s remaining text to flow into the vacated space:

	<figure>
		<img src="images/flow-clear.png" alt="Image illustrating the effects of floating a box without setting the clear property to control the flow of text around the box.">
		<figcaption>
			Identical to the previous example,
			save that there is now "sibling" text
			flowing with the "body" and "outer" text.
		</figcaption>
	</figure>

	However, if the 'clear' property on the <em>sibling</em> element is set to 'right'
	(i.e., the generated <em>sibling</em> box will not accept a position next to
	<a>floating</a> boxes to its right), the <em>sibling</em> content begins to flow below the
	float:

	<div class="example">
		<pre class="lang-css">
		#inner { float: right; width: 130px; color: blue }
		#sibling { clear: right; color: red }
		</pre>
	</div>

	<figure>
		<img src="images/flow-clear2.png" alt="Image illustrating the effects of floating an element with setting the clear property to control the flow of text around the element.">
		<figcaption>
			Now the "sibling" text moves down to below the "inner" text’s box,
			leaving blank space behind.
			The text following the "sibling" text flows after it as normal.
		</figcaption>
	</figure>

<h3 id="comp-abspos">
Absolute Positioning Example</h3>

	Next, we consider the effect of absolute positioning. Consider the following CSS
	declarations for <em>outer</em> and <em>inner</em>:

	<div class="example">
		<pre class="lang-css">
		#outer {
				position: absolute;
				top: 200px; left: 200px;
				width: 200px;
				color: red;
		}
		#inner { color: blue }
		</pre>
	</div>

	which cause the top of the <em>outer</em> box to be positioned with respect to its
	<a>containing block</a>. The <a>containing block</a> for a positioned box is established by the
	nearest positioned ancestor (or, if none exists, the <span>initial containing block</span>, as in
	our example). The top side of the <em>outer</em> box is ''200px'' below the top of the
	<a>containing block</a> and the left side is ''200px'' from the left side. The child box of
	<em>outer</em> is flowed normally with respect to its parent.

	<figure>
		<img src="images/flow-absolute.png" alt="Image illustrating the effects of absolutely positioning a box.">
		<figcaption>
			All of the text within #outer (the "outer" and "inner" text)
			moves down to an independent box in the lower right corner.
			The two halves of "body" text flow together.
		</figcaption>
	</figure>

	The following example shows an absolutely positioned box that is a child of a relatively
	positioned box. Although the parent <em>outer</em> box is not actually offset, setting
	its 'position' property to ''position/relative'' means that its box may serve as the containing
	block for positioned descendants. Since the <em>outer</em> box is an inline box that is
	split across several lines, the first inline box’s top and left edges (depicted by thick
	dashed lines in the illustration below) serve as references for 'top' and 'left' offsets.

	<div class="example">
		<pre class="lang-css">
		#outer {
				position: relative;
				color: red
		}
		#inner {
				position: absolute;
				top: 200px; left: -100px;
				height: 130px; width: 130px;
				color: blue;
		}
		</pre>
	</div>

	This results in something like the following:

	<figure>
		<img src="images/flow-abs-rel.png" alt="Image illustrating the effects of absolutely positioning a box with respect to a containing block.">
		<figcaption>
			The "inner" text is positioned in an independent box,
			relative to the top-left corner of the start of the "outer" text.
		</figcaption>
	</figure>

	If we do not position the <em>outer</em> box:

	<div class="example">
		<pre class="lang-css">
		#outer { color: red }
		#inner {
				position: absolute;
				top: 200px; left: -100px;
				height: 130px; width: 130px;
				color: blue;
		}
		</pre>
	</div>

	the <a>containing block</a> for <em>inner</em> becomes the <span>initial
	containing block</span> (in our example). The following illustration shows where
	the <em>inner</em> box would end up in this case.

	<figure>
		<img src="images/flow-static.png" alt="Image illustrating the effects of absolutely positioning a box with respect to a containing block established by a normally positioned parent.">
		<figcaption>
			Same as before,
			except now the "inner text" is positioned relative to the top-left corner of the page itself.
		</figcaption>
	</figure>

	Relative and absolute positioning may be used to implement change bars, as shown
	in the following example. The following fragment:

	<div class="example">
		<pre class="lang-html">
		&lt;p style="position: relative; margin-right: 10px; left: 10px;">
			I used two red hyphens to serve as a change bar. They
			will "float" to the left of the line containing THIS
			&lt;span style="position: absolute; top: auto; left: -1em; color: red;">--&lt;/span>
			word.
		&lt;/p>
		</pre>
	</div>

	might result in something like:

	<figure>
		<img src="images/changebar.png" alt="Image illustrating the use of floats to create a changebar effect.">
		<figcaption>
			The two red hyphens, indicating a change,
			sit in the left margin of the page
			on the line containing the word "THIS",
			regardless of what line that ends up being.
		</figcaption>
	</figure>

	First, the paragraph (whose <a>containing block</a> sides are shown in the
	illustration) is flowed normally. Then it is offset ''10px'' from the left edge
	of the <a>containing block</a> (thus, a right margin of ''10px'' has been
	reserved in anticipation of the offset). The two hyphens acting as change bars
	are taken out of the flow and positioned at the current line (due to 'top: auto'),
	''-1em'' from the left edge of its containing block (established by the P in
	its final position).	The result is that the change bars seem to "float" to the
	left of the current line.

<h2 id="ack">
Acknowledgments</h2>

	This module would not have been possible without input and support from many
	helpful people. Thanks to
	Rossen Atanassov,
	Bert Bos,
	Oriol Brufau,
	Tantek &Ccedil;elik,
	Arron Eicholz
	Sylvain Galineau,
	John Jansen,
	Chris Jones,
	Ian Kilpatrick,
	Anton Prowse.


<h2 class="no-num" id="changes">Changes</h2>

	The following significant changes were made since the
	<a href="https://www.w3.org/TR/2020/WD-css-position-3-20200519/">19 May 2020 Working Draft</a>:

	<ul>
		<li>Defined automatic sizing of non-replaced absolutely-positioned boxes with an aspect ratio.
			(<a href="https://github.com/w3c/csswg-drafts/issues/5151">Issue 5151</a>
			<blockquote>
				<p><ins>However, if the box has an aspect-ratio,
				then an [=automatic size=] in the [=ratio-dependent axis=]
				is instead resolved as a [=max-content size=].
				When both axes have an [=automatic size=],
				if only one axis has an ''inset/auto'' inset
				then that axis is the [=ratio-dependent axis=],
				else the [=block axis=] is the [=ratio-dependent axis=].
				An [=automatic size=] in the [=ratio-determining axis=]
				is determined as above.</ins></p>
			</blockquote>

		<li>Aligned resolution of auto margins and automatic sizes of positioned boxes with [[CSS2]].
			(<a href="https://github.com/w3c/csswg-drafts/issues/5374">Issue 5374</a>,
			 <a href="https://github.com/w3c/csswg-drafts/issues/5077">Issue 5077</a>,
			 <a href="https://github.com/w3c/csswg-drafts/issues/5327">Issue 5327</a>)
			<blockquote>
				<p>If this results in a [=sticky view rectangle=] size in any axis
				less than the size of the [=border box=] of the [=sticky=] box in that axis,
				then the effective [=end=]-edge inset in the affected axis is reduced
				(possibly becoming negative)
				to bring the [=sticky view rectangle=]’s size up to
				the size of the [=border box=] in that axis
				<ins>(where [=end=] is interpreted relative to the [=writing mode=] of the [=containing block=])</ins>.
			</blockquote>
			<blockquote>
				If neither is ''top/auto'',
				the position is over-constrained;
				<ins>(with respect to the [=writing mode=] of its [=containing block=])</ins>
				the [=computed value|computed=] [=CSS/end=] side value is ignored,
				and its [=used value=] becomes the negation of the [=CSS/start=] side.
			</blockquote>
			<blockquote>
				However,
				<ins>(all with respect to the [=writing mode=] of the [=containing block=]),
				if in the [=inline axis=]</ins>
				the <var>remaining space</var> is negative
				and both margins are ''margin/auto'',
				the [=inline-start|start=] margin resolves to zero
				and the [=inline-end|end=] margin receives the <var>remaining space</var>.
			</blockquote>
			<blockquote>
				<dl class=switch>
					: If its [=self-alignment property=] in the relevant axis is ''align-self/stretch''
					: If it is ''align-self/normal''
						and the box is [=non-replaced=] <ins>and has no ''inset/auto'' [=inset property|inset=] in the relevant axis</ins>
					::
						Its [=automatic size=] is its [=stretch-fit size=].

					: If its [=self-alignment property=] in the relevant axis is not ''align-self/stretch''
					: If it is ''align-self/normal''
						and the box is [=replaced=]
					: <ins>If it is ''align-self/normal''
						and has at least one ''inset/auto'' [=inset property|inset=] in the relevant axis</ins>
					::
						Its [=automatic size=] is its [=fit-content size=].
				</dl>
			</blockquote>
	</ul>

	The following significant changes were made since the
	<a href="https://www.w3.org/TR/2016/WD-css-position-3-20160517/">17 May 2016 Working Draft</a>:

	<ul>
		<li>Rewrote the whole spec for editorial clarity, technical precision, and compatibility with [[CSS-ALIGN-3]], [[CSS-WRITING-MODES-3]], [[CSS-BREAK-3]], and [[CSS-DISPLAY-3]].
	</ul>

<h2 class=no-num id=priv-sec>
Privacy and Security Considerations</h2>

This specification introduces no new privacy considerations.

If an attacker is able to inject arbitrary CSS,
positioned layout can make it easier to position elements the attacker has control of
over arbitrary other elements of the page,
potentially tricking users of the page.
(There are many routes to this attack: negative 'margin', 'transform', etc.
Don't let people apply arbitrary CSS to bits of your page.)

''position: fixed'' can allow a page to emulate modal dialogs,
potentially tricking a user into thinking they're interacting with the user agent
and entering in sensitive information that they page can then capture.
User agents must ensure that their native dialogs are positioned
in ways that the page cannot emulate;
in particular,
that at least some of the dialog is outside the "poisoned pixels" that web content can paint to.
